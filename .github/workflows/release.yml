# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                    PARKALOT SYSTEM - RELEASE MANAGEMENT                     â•‘
# â•‘                                                                              â•‘
# â•‘  Automated versioning, changelog generation, and release workflow           â•‘
# â•‘  Version: 1.0                                                                â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Release Management

on:
  push:
    branches:
      - main
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.github/**'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
      prerelease:
        description: 'Create pre-release'
        required: false
        type: boolean
        default: false

env:
  PHP_VERSION: '8.2'

jobs:
  # ============================================================================
  # ANALYZE COMMITS FOR VERSIONING
  # ============================================================================
  analyze:
    name: Analyze Commits
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.analyze.outputs.should_release }}
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest tag
        id: latest_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Analyze commits since last release
        id: analyze
        run: |
          LATEST_TAG="${{ steps.latest_tag.outputs.tag }}"

          # Get commits since last tag
          COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")

          # Determine if we should release
          SHOULD_RELEASE=false
          HAS_BREAKING=false
          HAS_FEAT=false
          HAS_FIX=false

          while IFS= read -r commit; do
            if [[ "$commit" =~ ^BREAKING|^.*!: ]]; then
              HAS_BREAKING=true
              SHOULD_RELEASE=true
            elif [[ "$commit" =~ ^feat ]]; then
              HAS_FEAT=true
              SHOULD_RELEASE=true
            elif [[ "$commit" =~ ^fix ]]; then
              HAS_FIX=true
              SHOULD_RELEASE=true
            fi
          done <<< "$COMMITS"

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "has_breaking=$HAS_BREAKING" >> $GITHUB_OUTPUT
          echo "has_feat=$HAS_FEAT" >> $GITHUB_OUTPUT
          echo "has_fix=$HAS_FIX" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: version
        run: |
          LATEST_TAG="${{ steps.latest_tag.outputs.tag }}"
          CURRENT_VERSION=${LATEST_TAG#v}

          # Parse version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          # Determine version bump
          RELEASE_TYPE="${{ github.event.inputs.release_type || 'auto' }}"

          if [ "$RELEASE_TYPE" = "auto" ]; then
            if [ "${{ steps.analyze.outputs.has_breaking }}" = "true" ]; then
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
            elif [ "${{ steps.analyze.outputs.has_feat }}" = "true" ]; then
              MINOR=$((MINOR + 1))
              PATCH=0
            elif [ "${{ steps.analyze.outputs.has_fix }}" = "true" ]; then
              PATCH=$((PATCH + 1))
            fi
          elif [ "$RELEASE_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$RELEASE_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [ "$RELEASE_TYPE" = "patch" ]; then
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"

          # Add prerelease suffix if requested
          if [ "${{ github.event.inputs.prerelease }}" = "true" ]; then
            NEW_VERSION="${NEW_VERSION}-rc.$(date +%Y%m%d%H%M%S)"
          fi

          echo "version=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: v$NEW_VERSION"

      - name: Generate changelog
        id: changelog
        run: |
          LATEST_TAG="${{ steps.latest_tag.outputs.tag }}"

          # Generate changelog
          CHANGELOG="## What's Changed\n\n"

          # Breaking changes
          BREAKING=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^BREAKING" --grep="^.*!:" 2>/dev/null || true)
          if [ -n "$BREAKING" ]; then
            CHANGELOG+="### Breaking Changes\n$BREAKING\n\n"
          fi

          # Features
          FEATURES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^feat" 2>/dev/null || true)
          if [ -n "$FEATURES" ]; then
            CHANGELOG+="### Features\n$FEATURES\n\n"
          fi

          # Bug fixes
          FIXES=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^fix" 2>/dev/null || true)
          if [ -n "$FIXES" ]; then
            CHANGELOG+="### Bug Fixes\n$FIXES\n\n"
          fi

          # Performance
          PERF=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --grep="^perf" 2>/dev/null || true)
          if [ -n "$PERF" ]; then
            CHANGELOG+="### Performance\n$PERF\n\n"
          fi

          # Other changes
          OTHER=$(git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --invert-grep --grep="^feat" --grep="^fix" --grep="^perf" --grep="^BREAKING" --grep="^docs" --grep="^chore" --grep="^ci" 2>/dev/null | head -20 || true)
          if [ -n "$OTHER" ]; then
            CHANGELOG+="### Other Changes\n$OTHER\n\n"
          fi

          # Escape for GitHub output
          CHANGELOG="${CHANGELOG//'%'/'%25'}"
          CHANGELOG="${CHANGELOG//$'\n'/'%0A'}"
          CHANGELOG="${CHANGELOG//$'\r'/'%0D'}"

          echo "changelog=$CHANGELOG" >> $GITHUB_OUTPUT

  # ============================================================================
  # RUN TESTS BEFORE RELEASE
  # ============================================================================
  test:
    name: Pre-Release Tests
    runs-on: ubuntu-latest
    needs: analyze
    if: needs.analyze.outputs.should_release == 'true' || github.event_name == 'workflow_dispatch'
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: parkalot_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          extensions: pdo, pdo_mysql, mbstring, xml, zip
          coverage: xdebug

      - name: Install dependencies
        run: |
          if [ -f composer.json ]; then
            composer install --no-progress --prefer-dist
          fi

      - name: Run tests
        run: |
          if [ -f phpunit.xml ] || [ -f phpunit.xml.dist ]; then
            ./vendor/bin/phpunit --testdox
          else
            echo "No PHPUnit config found, skipping tests"
          fi
        env:
          DB_HOST: 127.0.0.1
          DB_PORT: 3306
          DB_DATABASE: parkalot_test
          DB_USERNAME: root
          DB_PASSWORD: root

      - name: Run security checks
        run: |
          if [ -f composer.lock ]; then
            composer audit
          fi

  # ============================================================================
  # BUILD RELEASE ARTIFACTS
  # ============================================================================
  build:
    name: Build Release
    runs-on: ubuntu-latest
    needs: [analyze, test]
    if: needs.analyze.outputs.should_release == 'true' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          tools: composer:v2

      - name: Install production dependencies
        run: |
          if [ -f composer.json ]; then
            composer install --no-dev --optimize-autoloader --prefer-dist
          fi

      - name: Create release archive
        run: |
          VERSION="${{ needs.analyze.outputs.version }}"

          # Create build directory
          mkdir -p build

          # Copy necessary files
          rsync -av --progress . build/ \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='tests' \
            --exclude='node_modules' \
            --exclude='.env' \
            --exclude='.env.*' \
            --exclude='*.log' \
            --exclude='build'

          # Create tarball
          tar -czvf "parkalot-${VERSION}.tar.gz" -C build .

          # Create zip
          cd build && zip -r "../parkalot-${VERSION}.zip" . && cd ..

          # Generate checksums
          sha256sum "parkalot-${VERSION}.tar.gz" > "parkalot-${VERSION}.tar.gz.sha256"
          sha256sum "parkalot-${VERSION}.zip" > "parkalot-${VERSION}.zip.sha256"

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-artifacts
          path: |
            parkalot-*.tar.gz
            parkalot-*.zip
            parkalot-*.sha256

      - name: Build Docker image
        run: |
          VERSION="${{ needs.analyze.outputs.version }}"
          docker build -t parkalot:${VERSION} .

      - name: Save Docker image
        run: |
          VERSION="${{ needs.analyze.outputs.version }}"
          docker save parkalot:${VERSION} | gzip > "parkalot-docker-${VERSION}.tar.gz"

      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: parkalot-docker-*.tar.gz

  # ============================================================================
  # CREATE GITHUB RELEASE
  # ============================================================================
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [analyze, build]
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-artifacts
          path: artifacts/

      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: artifacts/

      - name: Create Git tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ needs.analyze.outputs.version }}" -m "Release ${{ needs.analyze.outputs.version }}"
          git push origin "${{ needs.analyze.outputs.version }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.analyze.outputs.version }}
          name: ${{ needs.analyze.outputs.version }}
          body: |
            ${{ needs.analyze.outputs.changelog }}

            ## Downloads

            | File | Description |
            |------|-------------|
            | `parkalot-${{ needs.analyze.outputs.version }}.tar.gz` | Source archive (tar.gz) |
            | `parkalot-${{ needs.analyze.outputs.version }}.zip` | Source archive (zip) |
            | `parkalot-docker-${{ needs.analyze.outputs.version }}.tar.gz` | Docker image |

            ## Installation

            ```bash
            # Download and extract
            wget https://github.com/${{ github.repository }}/releases/download/${{ needs.analyze.outputs.version }}/parkalot-${{ needs.analyze.outputs.version }}.tar.gz
            tar -xzvf parkalot-${{ needs.analyze.outputs.version }}.tar.gz

            # Or use Docker
            docker load < parkalot-docker-${{ needs.analyze.outputs.version }}.tar.gz
            docker run -p 80:80 parkalot:${{ needs.analyze.outputs.version }}
            ```
          draft: false
          prerelease: ${{ github.event.inputs.prerelease == 'true' }}
          files: |
            artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================================================
  # PUBLISH DOCKER IMAGE
  # ============================================================================
  publish-docker:
    name: Publish Docker Image
    runs-on: ubuntu-latest
    needs: [analyze, release]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ secrets.DOCKER_USERNAME }}/parkalot
            ghcr.io/${{ github.repository }}
          tags: |
            type=semver,pattern={{version}},value=${{ needs.analyze.outputs.version }}
            type=semver,pattern={{major}}.{{minor}},value=${{ needs.analyze.outputs.version }}
            type=semver,pattern={{major}},value=${{ needs.analyze.outputs.version }}
            type=raw,value=latest,enable=${{ github.event.inputs.prerelease != 'true' }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================================================
  # NOTIFY RELEASE
  # ============================================================================
  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [analyze, release, publish-docker]
    if: always() && needs.release.result == 'success'
    steps:
      - name: Send Slack notification
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "ðŸš€ New Release: ${{ needs.analyze.outputs.version }}",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "ðŸš€ ParkaLot ${{ needs.analyze.outputs.version }} Released!"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Release Details*\nâ€¢ Version: `${{ needs.analyze.outputs.version }}`\nâ€¢ Docker: `parkalot:${{ needs.analyze.outputs.version }}`\nâ€¢ <${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ needs.analyze.outputs.version }}|View Release>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
        continue-on-error: true

      - name: Update release status
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Version: ${{ needs.analyze.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- GitHub Release: Created" >> $GITHUB_STEP_SUMMARY
          echo "- Docker Image: Published" >> $GITHUB_STEP_SUMMARY
