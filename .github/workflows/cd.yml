# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘            PARKALOT SYSTEM - CONTINUOUS DEPLOYMENT                 â•‘
# â•‘                                                                    â•‘
# â•‘  Automated deployment pipeline with blue-green deployment,        â•‘
# â•‘  database migrations, monitoring, and rollback capabilities       â•‘
# â•‘  DevOps Pipeline v2.0                                              â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: CD Pipeline

on:
  push:
    branches: [main]
    tags: ['v*.*.*']
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        default: 'false'
        type: boolean
      rollback_version:
        description: 'Rollback to specific version (leave empty for normal deploy)'
        required: false
        type: string

concurrency:
  group: cd-${{ github.ref }}-${{ inputs.environment || 'staging' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # PRE-DEPLOYMENT VALIDATION
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  validate:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      short-sha: ${{ steps.version.outputs.short-sha }}
      deploy-env: ${{ steps.env.outputs.environment }}
      is-rollback: ${{ steps.check.outputs.is-rollback }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="$(date +'%Y.%m.%d')-$(git rev-parse --short HEAD)"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "short-sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Determine environment
        id: env
        run: |
          if [[ -n "${{ inputs.environment }}" ]]; then
            ENV="${{ inputs.environment }}"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            ENV="production"
          else
            ENV="staging"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "Deploying to: $ENV"

      - name: Check if rollback
        id: check
        run: |
          if [[ -n "${{ inputs.rollback_version }}" ]]; then
            echo "is-rollback=true" >> $GITHUB_OUTPUT
            echo "Rolling back to version: ${{ inputs.rollback_version }}"
          else
            echo "is-rollback=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate deployment
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                    DEPLOYMENT VALIDATION                           â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Environment: ${{ steps.env.outputs.environment }}"
          echo "  Version: ${{ steps.version.outputs.version }}"
          echo "  Is Rollback: ${{ steps.check.outputs.is-rollback }}"
          echo "  Triggered by: ${{ github.actor }}"
          echo "  Event: ${{ github.event_name }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # BUILD AND PUSH DOCKER IMAGE
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build:
    name: Build & Push Image
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.is-rollback == 'false'
    permissions:
      contents: read
      packages: write
      id-token: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
      image-version: ${{ steps.meta.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=sha-
            type=raw,value=${{ needs.validate.outputs.version }}
            type=raw,value=latest,enable=${{ github.ref == format('refs/heads/{0}', 'main') }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            APP_ENV=${{ needs.validate.outputs.deploy-env }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ needs.validate.outputs.version }}

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.version }}
          format: spdx-json
          output-file: sbom.spdx.json
        continue-on-error: true

      - name: Sign container image
        if: github.event_name != 'pull_request'
        env:
          COSIGN_EXPERIMENTAL: "true"
        run: |
          echo "Container signing would be performed here with cosign"
          # cosign sign ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
        continue-on-error: true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ github.run_number }}
          path: |
            sbom.spdx.json
          retention-days: 90

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # DATABASE BACKUP (Production only)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  backup:
    name: Database Backup
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: needs.validate.outputs.deploy-env == 'production'
    environment: production

    steps:
      - name: Create database backup
        env:
          DB_HOST: ${{ secrets.PRODUCTION_DB_HOST }}
          DB_USER: ${{ secrets.PRODUCTION_DB_USER }}
          DB_PASSWORD: ${{ secrets.PRODUCTION_DB_PASSWORD }}
          DB_NAME: ${{ secrets.PRODUCTION_DB_NAME }}
        run: |
          echo "Creating pre-deployment database backup..."
          BACKUP_NAME="backup_$(date +%Y%m%d_%H%M%S)_pre_${{ needs.validate.outputs.version }}.sql"
          echo "Backup would be created: $BACKUP_NAME"
          # mysqldump -h $DB_HOST -u $DB_USER -p$DB_PASSWORD $DB_NAME > $BACKUP_NAME
          # Upload to S3 or other backup storage
          echo "Backup completed successfully"

      - name: Store backup reference
        run: |
          echo "backup_timestamp=$(date +%Y%m%d_%H%M%S)" >> $GITHUB_OUTPUT

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # DEPLOY TO STAGING
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [validate, build]
    if: |
      needs.validate.outputs.deploy-env == 'staging' ||
      (needs.validate.outputs.deploy-env == 'production' && github.ref == 'refs/heads/main')
    environment:
      name: staging
      url: ${{ vars.STAGING_URL || 'https://staging.parkalot.example.com' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        if: secrets.STAGING_SSH_KEY != ''
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Deploy to staging
        env:
          IMAGE_TAG: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.version }}
          DEPLOY_HOST: ${{ secrets.STAGING_HOST }}
          DEPLOY_USER: ${{ secrets.STAGING_USER }}
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                    DEPLOYING TO STAGING                            â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Image: $IMAGE_TAG"
          echo "  Host: $DEPLOY_HOST"
          echo ""

          # Create deployment script
          cat > deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e

          echo "[$(date)] Starting deployment..."

          # Pull new image
          echo "[$(date)] Pulling image: $IMAGE_TAG"
          docker pull $IMAGE_TAG

          # Stop old container gracefully
          echo "[$(date)] Stopping existing container..."
          docker stop parkalot_app_staging --time=30 2>/dev/null || true
          docker rm parkalot_app_staging 2>/dev/null || true

          # Start new container
          echo "[$(date)] Starting new container..."
          docker run -d \
            --name parkalot_app_staging \
            --restart unless-stopped \
            -p 8080:80 \
            -e APP_ENV=staging \
            -e DB_HOST=$DB_HOST \
            -e DB_NAME=$DB_NAME \
            -e DB_USER=$DB_USER \
            -e DB_PASSWORD=$DB_PASSWORD \
            $IMAGE_TAG

          # Run database migrations
          echo "[$(date)] Running database migrations..."
          docker exec parkalot_app_staging php public/db-fix.php || true

          # Health check
          echo "[$(date)] Performing health check..."
          for i in {1..30}; do
            if curl -sf http://localhost:8080/api/index.php?route=garages > /dev/null; then
              echo "[$(date)] Health check passed!"
              exit 0
            fi
            echo "[$(date)] Waiting for application... ($i/30)"
            sleep 2
          done

          echo "[$(date)] Health check failed!"
          exit 1
          DEPLOY_SCRIPT

          echo "Deployment script created. Execute on target server."

          # If SSH is configured, deploy remotely
          # ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST 'bash -s' < deploy.sh

      - name: Verify staging deployment
        run: |
          echo "Verifying staging deployment..."
          # curl -sf ${{ vars.STAGING_URL }}/api/index.php?route=garages || echo "Verification pending"

      - name: Run smoke tests
        run: |
          echo "Running smoke tests on staging..."
          # Add actual smoke test commands here

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # INTEGRATION TESTS ON STAGING
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: needs.validate.outputs.deploy-env == 'production'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run integration tests
        run: |
          echo "Running integration tests against staging..."
          # Add integration test commands here

      - name: Generate test report
        if: always()
        run: |
          echo "## Integration Test Results" >> $GITHUB_STEP_SUMMARY
          echo "Tests completed at $(date)" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # DEPLOY TO PRODUCTION (Blue-Green)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, build, backup, integration-tests]
    if: |
      always() &&
      needs.validate.outputs.deploy-env == 'production' &&
      (needs.integration-tests.result == 'success' || needs.integration-tests.result == 'skipped')
    environment:
      name: production
      url: ${{ vars.PRODUCTION_URL || 'https://parkalot.example.com' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        if: secrets.PRODUCTION_SSH_KEY != ''
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Blue-Green Deployment
        env:
          IMAGE_TAG: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate.outputs.version }}
          DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
          DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘               DEPLOYING TO PRODUCTION (Blue-Green)                 â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Image: $IMAGE_TAG"
          echo "  Strategy: Blue-Green Deployment"
          echo ""

          # Create blue-green deployment script
          cat > deploy-production.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e

          BLUE_PORT=8080
          GREEN_PORT=8081

          # Determine current active deployment
          if docker ps --format '{{.Names}}' | grep -q 'parkalot_blue'; then
            CURRENT="blue"
            NEW="green"
            NEW_PORT=$GREEN_PORT
          else
            CURRENT="green"
            NEW="blue"
            NEW_PORT=$BLUE_PORT
          fi

          echo "[$(date)] Current: $CURRENT, Deploying: $NEW"

          # Pull new image
          echo "[$(date)] Pulling new image..."
          docker pull $IMAGE_TAG

          # Start new container
          echo "[$(date)] Starting $NEW container..."
          docker run -d \
            --name parkalot_$NEW \
            --restart unless-stopped \
            -p $NEW_PORT:80 \
            -e APP_ENV=production \
            $IMAGE_TAG

          # Wait for new container to be healthy
          echo "[$(date)] Waiting for $NEW container to be healthy..."
          for i in {1..60}; do
            if curl -sf http://localhost:$NEW_PORT/api/index.php?route=garages > /dev/null; then
              echo "[$(date)] $NEW container is healthy!"
              break
            fi
            if [ $i -eq 60 ]; then
              echo "[$(date)] $NEW container failed health check. Rolling back..."
              docker stop parkalot_$NEW && docker rm parkalot_$NEW
              exit 1
            fi
            sleep 2
          done

          # Switch traffic (update load balancer/nginx)
          echo "[$(date)] Switching traffic to $NEW..."
          # nginx -s reload or update load balancer

          # Stop old container after traffic switch
          echo "[$(date)] Stopping $CURRENT container..."
          docker stop parkalot_$CURRENT --time=30 2>/dev/null || true
          docker rm parkalot_$CURRENT 2>/dev/null || true

          echo "[$(date)] Deployment complete!"
          DEPLOY_SCRIPT

          echo "Blue-Green deployment script created."

      - name: Run database migrations
        run: |
          echo "Running production database migrations..."
          # docker exec parkalot_app php public/db-fix.php

      - name: Verify production deployment
        run: |
          echo "Verifying production deployment..."
          # curl -sf ${{ vars.PRODUCTION_URL }}/api/index.php?route=garages

      - name: Update deployment status
        run: |
          echo "## Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ needs.validate.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed at:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # POST-DEPLOYMENT MONITORING
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  monitor:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [validate, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')

    steps:
      - name: Monitor deployment health
        run: |
          echo "Monitoring deployment for 5 minutes..."
          ENV="${{ needs.validate.outputs.deploy-env }}"

          for i in {1..5}; do
            echo "Health check $i/5..."
            # Add actual health check commands
            sleep 60
          done

          echo "Deployment monitoring complete!"

      - name: Create deployment record
        run: |
          echo "Creating deployment record..."
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Deployment Record

          | Property | Value |
          |----------|-------|
          | Environment | ${{ needs.validate.outputs.deploy-env }} |
          | Version | ${{ needs.validate.outputs.version }} |
          | Commit | ${{ github.sha }} |
          | Deployed By | ${{ github.actor }} |
          | Timestamp | $(date -u +"%Y-%m-%dT%H:%M:%SZ") |
          EOF

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # ROLLBACK (Manual trigger)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.is-rollback == 'true'
    environment: ${{ needs.validate.outputs.deploy-env }}

    steps:
      - name: Perform rollback
        env:
          ROLLBACK_VERSION: ${{ inputs.rollback_version }}
          TARGET_ENV: ${{ needs.validate.outputs.deploy-env }}
        run: |
          echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
          echo "â•‘                    PERFORMING ROLLBACK                             â•‘"
          echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Environment: $TARGET_ENV"
          echo "  Rolling back to: $ROLLBACK_VERSION"
          echo ""

          # Pull the rollback version
          ROLLBACK_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$ROLLBACK_VERSION"
          echo "Rolling back to image: $ROLLBACK_IMAGE"

          # Deployment rollback steps would go here
          # docker pull $ROLLBACK_IMAGE
          # docker stop current_container
          # docker run ... $ROLLBACK_IMAGE

      - name: Verify rollback
        run: |
          echo "Verifying rollback..."
          # Add verification steps

      - name: Notify rollback complete
        run: |
          echo "## Rollback Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Rolled back to:** ${{ inputs.rollback_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ needs.validate.outputs.deploy-env }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Performed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # NOTIFICATION
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [validate, build, deploy-staging, deploy-production, monitor]
    if: always()

    steps:
      - name: Determine status
        id: status
        run: |
          if [[ "${{ needs.deploy-production.result }}" == "success" ]] || \
             [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=Deployment successful!" >> $GITHUB_OUTPUT
          elif [[ "${{ needs.deploy-production.result }}" == "failure" ]] || \
               [[ "${{ needs.deploy-staging.result }}" == "failure" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Deployment failed!" >> $GITHUB_OUTPUT
          else
            echo "status=cancelled" >> $GITHUB_OUTPUT
            echo "message=Deployment cancelled" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        if: secrets.SLACK_WEBHOOK_URL != ''
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "attachments": [{
                "color": "${{ steps.status.outputs.status == 'success' && '#28a745' || '#dc3545' }}",
                "blocks": [
                  {
                    "type": "header",
                    "text": {
                      "type": "plain_text",
                      "text": "ðŸš€ Deployment: ${{ steps.status.outputs.message }}"
                    }
                  },
                  {
                    "type": "section",
                    "fields": [
                      {"type": "mrkdwn", "text": "*Environment:*\n${{ needs.validate.outputs.deploy-env }}"},
                      {"type": "mrkdwn", "text": "*Version:*\n${{ needs.validate.outputs.version }}"},
                      {"type": "mrkdwn", "text": "*Deployed by:*\n${{ github.actor }}"},
                      {"type": "mrkdwn", "text": "*Repository:*\n${{ github.repository }}"}
                    ]
                  },
                  {
                    "type": "actions",
                    "elements": [
                      {
                        "type": "button",
                        "text": {"type": "plain_text", "text": "View Workflow"},
                        "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                      }
                    ]
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true

      - name: Send email notification
        if: secrets.NOTIFICATION_EMAIL != ''
        run: |
          echo "Email notification would be sent to: ${{ secrets.NOTIFICATION_EMAIL }}"
        continue-on-error: true

      - name: Create GitHub deployment
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ needs.validate.outputs.deploy-env }}';
            const status = '${{ steps.status.outputs.status }}' === 'success' ? 'success' : 'failure';

            console.log(`Creating deployment record for ${environment}: ${status}`);
        continue-on-error: true
